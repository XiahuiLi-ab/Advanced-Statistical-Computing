---
title: "Computing in Statistics: Data Wrangling"
---

## Practical 2: Wrangling and plotting tidily

This practical consists of three parts:

1.  Manipulating data;
2.  Building an R package to perform an exploratory analysis of these data;
3.  Optimizing code with respect to computational efficiency.

### Exercise 1: Data Wrangling using dplyr

Consider the Corruption Perceptions Index (CPI) data set. The CPI ranks 186 countries and territories by their perceived levels of public sector corruption, according to experts and business people.

The task is to manipulate the raw data by adding columns, building subsets, computing summary statistics, and arranging rows and columns, using dplyr package.

```{r}
library(readr)
library(dplyr)
CPIData <- read_csv("CPIData.csv")
```

```{r}
# (a) Order the data alphabetically by country
CPIData <- arrange(CPIData, Country)
head(CPIData)
```

```{r}
# (b) Which country has the lowest CPI, which country has the highest? State also the corresponding years.

arrange(CPIData, CPI) %>% slice(1)
arrange(CPIData, CPI)[1, ]

# arrange(CPIData, CPI) %>% filter(!is.na(CPIData)) %>% slice(n())
# arrange(CPIData, desc(CPI)) higest CPI
```

```{r}
# (c) Create a new column that contains the CPI devided by 10

CPIData <- mutate(CPIData, CPIDividedBy10 = CPI/10)
head(CPIData)
```

```{r}
# (d) Create a new column that contains the CPI relative to UK's CPI
CPIUK <- filter(CPIData, Country== "United Kingdom") %>% select(CPI)
CPIUK
length(unique(CPIData$Country))
rep(CPIUK, length(unique(CPIData$Country)))
ukscale <- unlist(rep(CPIUK, length(unique(CPIData$Country))))
CPIData <- mutate(CPIData, CPIRelativeToUK = CPI/ukscale)
head(CPIData)
filter(CPIData, Country == "United Kingdom") # check if CPIRelativeToUK = 1
```

```{r}
# (e) Which country has the lowest average CPI over years, which country has the highest
average <- summarise(mean = mean(CPI, na.rm = TRUE), group_by(CPIData, Country))
arrange(average, mean)[1,] # lowest average
arrange(average, desc(mean))[1,] # highest average
```

```{r}
# (f) How many countries have an average CPI larger than 85?
filter(average, mean>85)
```

```{r}
# (g) Delete the column created in (c)
CPIData <- dplyr::select(CPIData, -c(CPIDividedBy10))
CPIData <- dplyr::select(CPIData, -c(CPIRelativeToUK))
head(CPIData)
```

```{r}
# (h) Delete all rows where the CPI is NA.
sum(is.na(CPIData)) # check how many NAs
CPIDatacomplete <- filter(CPIData, !is.na(CPI))
head(CPIDatacomplete)
```

### Exercise 2: Data Wrangling about Joining Datasets

Using the gapminder dataset in the gapminder package, join together the CPI data with the gapminder data, joining by country and year, where common combinations exist. Study the resulting dataset. What problems do you note?

```{r}
library(gapminder)
head(gapminder) # check the dataset
names(CPIData) <- c("country", "year", "CPI") # ensure names are consistent across datasets
CPIData %>% inner_join(gapminder) %>% print(n = 20)

```

```{r}
CPI_gap <- CPIData %>% inner_join(gapminder)
```

Problems

```{r}
# Check the original data dimensions
dim(gapminder)
dim(CPIData)
```

```{r}
# Check the joined data dimensions
dim(CPI_gap)
```

```{r}
# Compare unique countries before and after
length(unique(gapminder$country))
length(unique(CPIData$country))
length(unique(CPI_gap$country))
```

```{r}
# Check year ranges
range(gapminder$year)
range(CPIData$year)
range(CPI_gap$year)
```

```{r}
# Look for unmatched countries
setdiff(gapminder$country, CPIData$country)
```

### Exercise 3: Plotting the Data using ggplot2

The aim of this exercise is to generate tidy and reproducible plots using ggplot2 package to plot certain aspects of the data in a variety of formats.

```{r}
head(CPI_gap)
```

```{r}

# a scatter plot of population against CPI, where the size of the point and colour are related to the GDP and continent respectively

library(ggplot2)

ggplot(CPI_gap) + geom_point(aes(x = pop, y = CPI, size = gdpPercap, colour = continent), na.rm = T) + scale_x_log10()
```

### Exercise 4: Additional Plotting Exercise

Based on the exploration of the data, generate additional plots of the data that show interesting characteristics of the data variable.

```{r, warning = FALSE}
# Life expectancy vs CPI
ggplot(CPI_gap, aes(x = lifeExp, y = CPI, color = continent)) +
  geom_point(alpha = 0.6) +
  labs(title = "Life Expectancy vs CPI",
       x = "Life Expectancy (years)", y = "CPI")
```

```{r, warning = FALSE}
# CPI distribution by continent
ggplot(CPI_gap, aes(x = continent, y = CPI, fill = continent)) +
  geom_boxplot(alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.3) +
  scale_y_log10() +
  labs(title = "CPI Distribution by Continent",
       x = "Continent", y = "CPI (log scale)")
```

### Exercise 5: Plotting Results from Practical 1

```{r}
# source("Computing in Statistics_Introduction.r")
# library(knitr)
# Extract R code from the .qmd file
# purl("Computing in Statistics_Introduction.qmd", output = "extracted_code.R")
# Then source the extracted R code
# source("extracted_code.R")
```

```{r}
library(ggplot2)

library(ggplot2)
winddat <- read.csv("WindData (1).csv")
power <- function(w) {
    n <- length(w)
    p <- rep(0, n)
    for (i in 1:n) {
        if (w[i] < 3.5) {
            p[i] <- 0
        } else if (w[i] <= 14) {
            p[i] <- exp(-213.974 * exp(-0.633 * w[i]))
        } else if (w[i] < 25) {
            p[i] <- 1
        } else {
            p[i] <- 0
        }
    }
    return(p)
}

# Plot
w <- seq(0, 40, 0.01)
p <- power(w)
k <- 1.679
lambda <- 10.128
fvals <- dweibull(w, k, lambda)
dat <- data.frame(cbind(w, p, fvals))
ggplot(dat) + 
  geom_line(aes(x = w, y = p)) + 
  labs(title = "Wind turbine power output",
       x = "Wind speed (knots)", y = "% of total kilowatts") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    legend.position = "none"
  )

```

```{r}
ggplot(winddat, aes(x = speed)) + 
  geom_histogram(aes(y = after_stat(density)), binwidth = 3, fill = "darkgrey") + 
  geom_line(data = dat, aes(x=w, y=fvals, color = "tomato"), linetype = "dashed") + 
  labs(title = "Histogram of Wind Data",
       x = "Hourly wind speed (knots)", 
       y = "Probability density") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    legend.position = "none"
  )
```

```{r}
rejectSample <- function(n, k, lambda){
  
  # determine bound of box to sample in: Define a bounding box that encloses the Weibull PDF
  mean <- lambda * gamma(1 + 1/k) # Calculate theoretical mean
  sd <- lambda * sqrt(gamma(1 + 2/k) - gamma(1 + 1/k)^2) # Calculate theoretical SD
  xrange <- mean + 5 * sd # Set x-range to cover most of distribution
  pdf <- dweibull(seq(0, xrange, length = 1000), k, lambda) # Evaluate PDF
  yrange <- 1.1 * max(pdf) # Set y-range slightly above max PDF value
  
  # create samples
  sample <- NULL
  while(length(sample) < n){
    x <- runif(1, 0, xrange) # Generate random points uniformly within this box
    y <- runif(1, 0, yrange)
    f <- dweibull(x, k, lambda) # True PDF value at x
    if (y <= f){ # If point is under PDF curve
      sample <- c(sample, x) # Accept the x-value as sample
}
  }
  return(sample)
}

inverseCDFSample <- function(n, k, lambda){
  y <- runif(n)
  x <- qweibull(y, k, lambda)
  return(x)
}

```

```{r}
rjsamp <- rejectSample(10000, k, lambda)
icsamp <- inverseCDFSample(10000, k, lambda)
```

```{r}
samps <- data.frame(cbind(c(rjsamp, icsamp)), rep(c("RJ", "IC"), each = 1000))
names(samps) <- c("samp", "type")
head(samps)
```

```{r}
ggplot(samps) + 
  geom_density(aes(x = samp, fill = type), alpha = 0.8) +  # Increased alpha
  geom_line(data = dat, aes(x = w, y = fvals), 
            color = "tomato", linetype = "dashed", size = 1.5) +  # Thicker, brighter line
  scale_fill_manual(values = c("navy", "darkgreen", "darkred", "purple")) +  # Dark colors
  labs(title = "Sample Density Distribution", x = "Sample Value", y = "Density") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 12),
    legend.position = "bottom"
  )
```
