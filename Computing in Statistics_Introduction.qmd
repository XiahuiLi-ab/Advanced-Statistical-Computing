---
title: "Computing in Statistics: Introduction"
---

## Practical 1: Turning Algorithms into code

A company is considering **whether to install a wind turbine at a particular site** in the UK. The company wishes to estimate **how much wind power would be generated at the site**. There are also characteristics of the site that are of interest so that the company can decide **what type of turbine to install**. To answer these questions, the company needs you to develop software that can simulate wind speed and the power produced by these wind speeds.

For a given wind speed, $w$ in knots, the proportion of kilowatt power produced, $P(w)$ (as a proportion of the maximum power the turbine can produce), is given by the mathematical function:

$P(w) = 0$ if $w<3.5$

$P(w) = exp(-213.974exp(-0.633w))$ if $3.5 \leq w \leq 14$

$P(w) = 1$ if $14 \leq w \leq 25$

$P(w) = 0$ if $w \geq 25$

The power function is zero until there is enough wind to turn the turbine (at 3.5 knots). The power then increases until it reaches the maximum that the turbine can produce. At 25 knots, it is too dangerous to use the turbine, so it produces no power.

### Exercise 1: Wind Power Background

Write a function that computes the power for a given vector of wind speeds. Use this function to create a plot.

```{r}
# input: wind speed
# output: power

power_func <- function(w){
  
  n <- length(w)
  power <- rep(0, n)
  for (i in 1:n){
    if (w[i] < 3.5){
      power[i] <- 0
    } else if (w[i] <= 14){
      power[i] <- exp(-213.974*exp(-0.633*w[i]))
    } else if (w[i] < 25){
      power[i] <- 1
    } else {
      power[i] <- 0
    }
  }
  
  return(power)
}
```

```{r}
w <- seq(0, 40, 0.01)
power <- power_func(w)

plot(w, power, type = "l", lwd = 1.5, xlab = "Wind speed (knots)", ylab = "% of total kilowatts", main = "Wind turbine power output")
```

### Exercise 2: The Data

At the proposed site, the wind speed was recorded hourly for approximately 440 days. The data are stored in a comma separated value file (.csv).

```{r}
library(readr)
WindData <- read_csv("C:/Users/Lxhan/OneDrive - University of St Andrews/Desktop/Advanced Bayesian Inference/Advanced Computation/WindData (1).csv")$speed
str(WindData)
```

The climatologists involved decide that wind speed is best modelled using a Weibull distribution. The Weibull distribution has two parameters: a shape parameter $k$ and a scale parameter $\lambda$. The probability density function can be computed using the $\text{dweibull}$ function in R. The climatologists compute the following estimates of these parameters for these data: $\hat{k} = 1.679$ and $\hat{\lambda}=10.128$.

Use the dweibull function and the parameter estimates to produce a plot.

```{r}
k <- 1.679
lambda <- 10.128
hist(WindData, col = "grey95", border = "grey75", prob = TRUE, xlab = "Hourly wind speed (knots)", ylab = "Probability density")
lines(w, dweibull(w, shape = k, scale = lambda), lwd = 1.5)
```

### Exercise 3: Rejection Sampler

The rejection sampler works as follows. Repeat until you have $n$ samples:

1.  Pick a random coordinate $x$.
2.  Pick a random coordinate $y$.
3.  Compute the probability density at $x$, $f(x)$.
4.  If $y\leq f(x)$, the accept $x$.

\(a\) Write a function that has inputs $n$, $k$, and $\lambda$ and outputs $n$ samples from the Weibull distribution using a rejection sampling method.

```{r}
rejectSample <- function(n, k, lambda){
  
  # determine bound of box to sample in: Define a bounding box that encloses the Weibull PDF
  mean <- lambda * gamma(1 + 1/k) # Calculate theoretical mean
  sd <- lambda * sqrt(gamma(1 + 2/k) - gamma(1 + 1/k)^2) # Calculate theoretical SD
  xrange <- mean + 5 * sd # Set x-range to cover most of distribution
  pdf <- dweibull(seq(0, xrange, length = 1000), k, lambda) # Evaluate PDF
  yrange <- 1.1 * max(pdf) # Set y-range slightly above max PDF value
  
  # create samples
  sample <- NULL
  while(length(sample) < n){
    x <- runif(1, 0, xrange) # Generate random points uniformly within this box
    y <- runif(1, 0, yrange)
    f <- dweibull(x, k, lambda) # True PDF value at x
    if (y <= f){ # If point is under PDF curve
      sample <- c(sample, x) # Accept the x-value as sample
}
  }
  return(sample)
}
```

\(b\) Using the sampler to answer the following questions: what is the mean hourly power that could be produced at the site?

```{r}
# compute mean hourly power
samps <- rejectSample(500, k, lambda)
powerSamps <- power_func(samps)
mean(powerSamps)
```

### Exercise 4: Monte Carlo Error

When you report the mean hourly power produced, the company ask how accurate that estimate is. Monte Carlo method are simulation-based methods, so every time you estimate the mean power you will get a different answer. The company wants to know how much that answer changes. One way to answer that is to compute the mean many times and quantify how much it changes. Repeat $m$ times:

1.  Generate $n$ samples using rejection sampler function $f(n,k,\lambda)$.
2.  Compute power produced by each wind speed.
3.  Compute mean power produced.
4.  Compute standard deviation of mean power.

In practice, it is usually not feasible to simulate multiple times in order to quantify Monte Carlo error, so the following approximation is used: $\sigma/sqrt(n)$, where $\sigma$ is the standard deviation of the samples and $n$ is the number of samples.

Write a function with inputs $m, n, f, k$ and $\lambda$, and which outputs the standard deviation of the mean power from $n$ samples.

```{r}
estPowerSD <- function(m, n, f, k, lambda){
  means <- rep(0:m)
  for (i in 1:m){
    samp <- f(n, k, lambda)
    means[i] <- mean(power_func(samp))
  }
  return(sd(means))
}
estPowerSD(100, 500, rejectSample, k, lambda)
```

### Exercise 5: Inverse CDF Sampler

An alternative method is proposed for sampling from the Weibull distribution; it is called the inverse CDF sampler or sometimes called the probability integral transform. The idea of this method is to use the cumulative distribution function.

In this method, you pick a random number of the $y$-axis (between 0 and 1), then use the inverse CDF qweibull to figure out the corresponding value on the $x$-axis. You take this value as a sample. Notice, there is no rejection here, every iteration leads to a sample.

\(a\) Write out the pseudo-code the algorithm for the inverse CDF sampler. What are the inputs, what are the outputs?

1.  Generate uniform random numbers $U\sim Uniform(0, 1)$
2.  Apply the inverse CDF: $X = F^{-1}(U)$
3.  $X$ will follow the target distribution (Weibull)

```         
Generate n uniform random numbers between 0 and 1
```

```         
Transform uniform numbers using Weibull quantile function
```

\(b\) Write a function that implements this algorithm.

```{r}
inverseCDFSample <- function(n, k, lambda){
  y <- runif(n)
  x <- qweibull(y, k, lambda)
  return(x)
}
```

\(c\) Use this sampler to estimate the mean power produced at the site.

```{r}
samps <- inverseCDFSample(1000, k, lambda)
powerSamps <- power_func(samps)
mean(powerSamps)
```

### Exercise 6: Comparing the Samplers

The methods can be compared by their Monte Carlo error and by how long it takes to generate samples. The time it takes to execute a statement can be computed using the function system.time.

Compute the Monte Carlo error for each sampler and the time it takes to generate 10000 samples for each. Write a sentence comparing the methods and suggest which one should be used.

```{r}
system.time(rejectSample(10000, k, lambda))
system.time(inverseCDFSample(10000, k, lambda))
```

```{r}
estPowerSD(10, 1000, rejectSample, k, lambda)
estPowerSD(10, 1000, inverseCDFSample, k, lambda)
```

### Exercise 7: How Many Samples?

The company decides to use the inverse CDF sampler as that is the one they are familiar with. They want to know how many samples they need to take for a Monte Carlo error of 0.05. A vector of possible sample sizes can be created using the commend:

```{r}
nsamp <- seq(5, 100, 5)
```

Write an algorithm to compute the Monte Carlo error for each sample size and store it. Implement this algorithm and create a plot.

```{r}
err <- rep(0, length(nsamp))
for (i in 1:length(nsamp)){
  err[i] <- estPowerSD(nsamp[i], 1000, inverseCDFSample, k, lambda)
}
```

```{r}
plot(nsamp, err, type = "b", xlab = "Number of Samples", ylab = "Monte Carlo Error")
abline(h = 0.05, col = "red", lty = "dotted")
```

### Exercise 8: Finally

The company has three questions about the proposed wind turbine site:

1.  What is the total daily average power that could be produced at the site?
2.  What percentage of the time is the wind speed too low to produce power?
3.  What percentage of the time does the wind speed produce maximum power?

To help answer these questions, below is the code to answer the question: how often does the wind speed exceed the safe value of 25 knots? Suppose samples is a vector of wind speeds:

```{r}
# Example: how often does wind speed exceed 25 knots
samples <- inverseCDFSample(10000, k, lambda) # generate wind speed samples
unsafe <- samples > 25
percentage_unsafe <- 100 * mean(unsafe)
percentage_unsafe
```

Using the inverse CDF sampler, give an answer to each of the company's questions along with the code to produce these answers. For the first question, the company may ask for a range of plausible values for the average daily power produced, how could you provide this?

```{r}
# Question 1: daily average power?
samples <- inverseCDFSample(24 * 1000, k, lambda) # generate wind speed samples
psamples <- power_func(samples) # convert wind speed to power
pmat <- matrix(psamples, nr = 24) # organize into daily structure, each column represents one day, each row represents the same hour across 1000 days
dailyp <- colSums(pmat) # calculate total daily energy production
mean(dailyp)
quantile(dailyp, prob = c(0.025, 0.975)) # calculate confidence interval
```

```{r}
# Question 2: percentage time wind speed too low
samples <- inverseCDFSample(1000, k, lambda)
100 * sum(samples < 3.5) / length(samples)
```

```{r}
# Question 3: percentage time wind speed produces maximum power?
samples <- inverseCDFSample(1000, k, lambda)
100 * sum(samples > 14 & samples <= 25) / length(samples)
```

```{r}
100 * (pweibull(25, k, lambda) - pweibull(14, k, lambda))
```
